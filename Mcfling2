local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local PhysicsService = game:GetService("PhysicsService")
local LocalPlayer = Players.LocalPlayer
local Workspace = game:GetService("Workspace")

local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

local partsToAlign = {}
local isAlive = true

-- Setup collision groups for player interactions
local function setupCollisionGroups()
    if not PhysicsService:CollisionGroupExists("BypassBarrier") then
        PhysicsService:CreateCollisionGroup("BypassBarrier")
    end
    
    if not PhysicsService:CollisionGroupExists("Barrier") then
        PhysicsService:CreateCollisionGroup("Barrier")
    end
    
    -- Set collision rules: BypassBarrier should not collide with Barrier
    PhysicsService:CollisionGroupSetCollidable("BypassBarrier", "Barrier", false)
end

local function configurePart(part)
    part.Transparency = 1  -- Invisible
    part.CanCollide = false
    PhysicsService:SetPartCollisionGroup(part, "BypassBarrier")  -- Set to the "BypassBarrier" collision group
end

-- Fling methods
local function applyFlingMethods(part)
    -- Fling method using BodyVelocity
    local bodyVelocity = Instance.new("BodyVelocity", part)
    bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)  -- Max force to fling players
    bodyVelocity.Velocity = Vector3.new(math.random(-10000, 10000), math.random(10000, 20000), math.random(-10000, 10000))  -- Random high fling velocity

    -- Spin method using BodyAngularVelocity
    local bodyAngularVelocity = Instance.new("BodyAngularVelocity", part)
    bodyAngularVelocity.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)  -- Unlimited torque for spinning
    bodyAngularVelocity.AngularVelocity = Vector3.new(math.random(-10000, 10000), math.random(-10000, 10000), math.random(-10000, 10000))  -- Random high angular velocity
end

-- Attach the part to the player using AlignPosition and AlignOrientation
local function align(Part0, Part1)
    if not (Part0 and Part1) then return end -- Check if parts are valid

    Part0.CustomPhysicalProperties = PhysicalProperties.new(0.1, 0.1, 0.1, 0.1, 0.1)
    local att1 = Instance.new("Attachment", Part1)
    local att0 = Instance.new("Attachment", Part0)

    -- AlignPosition to keep the part strongly attached
    local ap = Instance.new("AlignPosition", att0)
    ap.ApplyAtCenterOfMass = true
    ap.MaxForce = math.huge  -- Unlimited force to prevent detachment
    ap.MaxVelocity = math.huge  -- Ensure very fast attachment movement
    ap.ReactionForceEnabled = false
    ap.Responsiveness = 999999999  -- Maximum responsiveness
    ap.RigidityEnabled = true  -- Acts like welded together
    ap.Attachment0 = att0
    ap.Attachment1 = att1

    -- AlignOrientation to maintain rotation
    local ao = Instance.new("AlignOrientation", att0)
    ao.MaxAngularVelocity = math.huge  -- Infinite angular velocity
    ao.MaxTorque = math.huge  -- Unlimited torque
    ao.PrimaryAxisOnly = false
    ao.ReactionTorqueEnabled = false
    ao.Responsiveness = 999999999  -- Maximum responsiveness
    ao.RigidityEnabled = true  -- Acts like welded
    ao.Attachment0 = att0
    ao.Attachment1 = att1

    spawn(function()
        while RunService.Heartbeat:Wait() and Part0 and Part0.Parent do
            if humanoidRootPart and isAlive then
                Part1.Position = humanoidRootPart.Position
            end
        end
    end)
end

local function handlePart(v)
    if v:IsA("BasePart") and not v.Anchored and not game.Players:GetPlayerFromCharacter(v.Parent) then
        v:ClearAllChildren()
        v.CanCollide = false
        local part = Instance.new("Part", v)
        part.CFrame = v.CFrame
        part.CanCollide = false
        part.Anchored = true
        part.Size = v.Size + Vector3.new(0.1, 0.1, 0.1)
        part.Transparency = 1  -- Invisible
        configurePart(part)
        align(v, part)
        applyFlingMethods(part)  -- Apply all fling methods

        -- Set up collision groups
        PhysicsService:CreateCollisionGroup("LocalPlayer")
        PhysicsService:CreateCollisionGroup("OtherPlayers")
        PhysicsService:CollisionGroupSetCollidable("LocalPlayer", "LocalPlayer", false)
        PhysicsService:CollisionGroupSetCollidable("LocalPlayer", "OtherPlayers", false)
        PhysicsService:CollisionGroupSetCollidable("OtherPlayers", "OtherPlayers", true)
        PhysicsService:CollisionGroupSetCollidable("OtherPlayers", "LocalPlayer", false)
        PhysicsService:SetPartCollisionGroup(part, "LocalPlayer")
        table.insert(partsToAlign, part)

        -- Teleport to part when detached
        RunService.RenderStepped:Connect(function()
            if part and humanoidRootPart and (part.Position - humanoidRootPart.Position).Magnitude > 5 then
                humanoidRootPart.CFrame = part.CFrame + Vector3.new(0, 5, 0) -- Teleport to the part if detached
            end
        end)
    end
end

-- Search for the first unanchored model named "Part"
for _, v in pairs(Workspace:GetDescendants()) do
    if v:IsA("BasePart") and not v.Anchored and v.Name == "Part" then
        handlePart(v)
        break
    end
end

-- Character events
LocalPlayer.CharacterAdded:Connect(function(newCharacter)
    character = newCharacter
    humanoidRootPart = character:WaitForChild("HumanoidRootPart")
    isAlive = true
    for _, part in ipairs(partsToAlign) do
        if part and part.Parent then
            align(part.Parent, part)
        end
    end
end)

character:WaitForChild("Humanoid").Died:Connect(function()
    isAlive = false
end)

-- Setup collision groups
setupCollisionGroups()

-- Ensure the script runs smoothly across servers
if humanoidRootPart then
    humanoidRootPart.AncestryChanged:Connect(function(_, parent)
        if not parent then
            isAlive = false
        end
    end)
end
